# zku.ONE C-4

**_Discord:_** mehultodi116@gmail.com <br/>
**_Email:_** kid116#4889

## Week 4
### P1: Theoretical Questions
<hr>

#### Q1
**Explain briefly the various ways in which the blockchain can enable people to sync to their network effectively.**

- Full nodes are still the most secure way to sync up to a blockchain network effectively but it comes at certain cost. Running a full node requires us to download and download and verify the entire chain which can take large storage space and time. It requires us to have a moderately powered laptop as well as can be inferred from the fact that an SSD is mandatory now to fully synchronize the Ethereum blockchain as an HDD can't keep up with the rate of operations needed to be performed.

- An unsecure way to interact with the blockchain is to connect to some full nodes and out complete trust their relayed messages about the validity of transactions. This allows us to reap the benifits of the network without having to invest practically any type of resources but this is not recommended.

- Recently invented light clients need to download only the block headers of the blockchain which requires only about 100 MB of storage space and low computational power. It can also synchronize with the in a fraction of the time which is about an hour. These block headers are useful in minimizing the trust involved. This is because the block headers contain a piece of information called the Merkle tree root. The Merkle tree root is like a fingerprint of all information on the blockchain about account balances and smart contract storage. A light client may need to request information from full nodes such as the balance of a specific account. Knowing the fingerprints for each block, a light client can verify whether the answer given by the full node matches with the fingerprint it has. 

- Currently, light clients have a trusted blockchain checkpoint build into their code to achieve sync-up within seconds. Light client users are trusting the client developers to integrate a valid checkpoint. This tradeoff is considered acceptable as users already need to trust the developers for the client implementation.

- Finally, the latest breakthrough in the field is light clients using zk-proofs to prove the validity of a number of blocks at a time combining the speed of light clients with the trustlessness of full nodes.

#### Q2
**Give a high level overview of how Plumo is able to compress a sequence of blocks into a single proof.**

Celo PoS light-clients need to only download epoch block headers which contain information about the current validator set and it uses BLS signature to aggregate validator signatures which combine a large number of validator signatures into one signature per block. These two innovations reduce the time and data required to sync significantly. But Plumo takes it one step further by introducing zk-SNARK proofs into the mix which allows light-clients to trustlessly verify transactions from epoch X to X + Y where Y may be hundreds of epochs and therefore achieve sync at lighting speeds. These proofs are generated by a prover program that can be run by multiple nodes across the Celo network. Proofs are then requested by light-clients which they can verify using the verification key that is included with the binary.

#### Q3
**Cite two differences of Harmony and Celo blockchain's consensus algorithms.**

- In Celo's IBFT consensus mechanism, there is an election held for the inclusion of validators into the active validator set. One can vote in this election by staking LockedGold and is incentivized with rewards if the validator chosen by them gets elected whereas there is no such election. Therefore, there is dynamic validator set in case of Celo's IBFT mechanism compared to Harmony's static validator set. Also, aspiring validators must be part of a validator groups analogous to political parties to become validators in Celo's blockchain unlike Harmony.

- In Celo's blockchain, validators are incentivized to be active via uptime rewards whereas inactive validators (who haven't validated at least 2/3rd of the blocks in an epoch) are just removed from the pool of active validators in case of Harmony. 

### P2: Final Project
<hr>

#### Q1
<!-- **Write down any new idea(s) that you have since last week.**

    [answer] -->

**Evaluate and rank your three project ideas (and your new idea(s), if any) from last week in terms of implementation difficulty, potential user base, and the importance of ZK in the idea.**

- In term of implementation difficulty, Scotland Yard would be the most challenging followed by Telepathy and then Higher Lower.

- I think a particularly famous game like Scotland Yard would attract the most number of players. I don't think there would be much of a difference between the user base for Telepathy and Higher-Lower however I feel Telepathy would be more appealing to the users.

- All of these games use zk-SNARK to hide certain player's game variables and therefore I feel the importance of ZK is the same for all the ideas. However in case of Scotland Yard, ZK-Proofs may also be used to verify if the moves made by the player is valid or not.

**Which of your ideas are you more inclined to do as your final project? Why?**

Honestly, I'm more inclined towards taking up Scotland Yard as the final-project because it's potential to attract a large user base and because of it's challenging nature however I doubt I could complete it within a few weeks. Therefore, I would probably choose to go with the safer option of Telepathy.

### P3: Frontend Assignment
<hr>

#### Q1
**Briefly explain the webpack configurations in the NextJS config file.**

The file makes certain modifications to the default webpack configuration for clients i.e. not the server. Firstly, it adds the `ProvidePlugin` plugin for `global` module to the existing list of plugins which allows this module to be used anywhere in the source code without explicit imports. Secondly, it sets certain fallback conditions in-case a module resolution fails. Setting the fallback condition for a module to `false` does not allow inclusion of a polyfill for the module, otherwise a polyfill may be provided.
